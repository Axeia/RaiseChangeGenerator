using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Linq;
using System.Text;

[Generator(LanguageNames.CSharp)]
public class Generator : IIncrementalGenerator
{
    private static readonly DiagnosticDescriptor MissingReactiveObjectDiagnostic = new(
        id: "RG001",
        title: "Class must inherit from ReactiveObject or implement IReactiveNotifyPropertyChanged",
        messageFormat: "Class '{0}' uses ReactiveUI proxy properties but does not inherit from ReactiveObject or implement IReactiveNotifyPropertyChanged.",
        category: "ReactiveGenerator",
        DiagnosticSeverity.Error,
        isEnabledByDefault: true,
        description: "Classes using these attributes must support ReactiveUI's RaisePropertyChanged method.");

    public record FieldInfo(string FieldName, string PropertyName, string Type, string ContainingClass, string Namespace, List<string> AlsoNotifyProperties);

    public record ProxyPropertyInfo(string PropertyName, string ProxyPropertyPath, string Type, string FieldName, string ContainingClass, string Namespace, List<string> AlsoNotifyProperties);

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var reactiveFields = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => IsFieldWithRaiseChange(node),
                transform: static (ctx, _) => (Info: GetFieldInfo(ctx), ClassSymbol: GetClassSymbol(ctx), Location: ctx.Node.GetLocation()))
            .Where(t => t.Info is not null && t.ClassSymbol is not null);

        var proxyFields = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => IsFieldWithRaiseChangeProxy(node),
                transform: static (ctx, _) => (Infos: GetProxyPropertyInfos(ctx), ClassSymbol: GetClassSymbol(ctx), Location: ctx.Node.GetLocation()))
            .Where(t => t.Infos.Any() && t.ClassSymbol is not null);

        var groupedReactiveFields = reactiveFields
            .Collect()
            .Select((fields, _) => fields
                .GroupBy(f => f.Info!.ContainingClass)
                .Select(g => (ClassName: g.Key, Fields: g.ToList()))
            );

        context.RegisterSourceOutput(groupedReactiveFields, (ctx, groups) =>
        {
            foreach (var (className, fields) in groups)
            {
                var classSymbol = fields.First().ClassSymbol!;
                if (!ClassHasReactiveUISupport(classSymbol))
                {
                    ctx.ReportDiagnostic(Diagnostic.Create(MissingReactiveObjectDiagnostic, fields.First().Location, classSymbol.ToDisplayString()));
                    continue;
                }
                var source = GenerateReactivePropertiesForClass([.. fields.Select(f => f.Info!)]);
                ctx.AddSource($"{className.Replace(".", "_")}_Reactive.g.cs", SourceText.From(source, Encoding.UTF8));
            }
        });

        context.RegisterSourceOutput(proxyFields, (ctx, t) =>
        {
            if (!ClassHasReactiveUISupport(t.ClassSymbol!))
            {
                ctx.ReportDiagnostic(Diagnostic.Create(MissingReactiveObjectDiagnostic, t.Location, t.ClassSymbol!.ToDisplayString()));
                return;
            }
            var source = GenerateProxyProperties(t.Infos);
            var fileName = $"{t.Infos.First().ContainingClass.Replace(".", "_")}_{t.Infos.First().FieldName}_Proxy.g.cs";
            ctx.AddSource(fileName, SourceText.From(source, Encoding.UTF8));
        });
    }

    static string GenerateReactivePropertiesForClass(List<FieldInfo> fields)
    {
        var firstField = fields.First();
        var sb = new StringBuilder();

        // 1. Add the nullable directive and auto-generated header
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using ReactiveUI;");
        sb.AppendLine();

        if (!string.IsNullOrEmpty(firstField.Namespace))
        {
            sb.AppendLine($"namespace {firstField.Namespace}");
            sb.AppendLine("{");
        }

        // Since you stopped nesting, we just grab the last part of the class name
        var className = firstField.ContainingClass.Split('.').Last();
        sb.AppendLine($"    partial class {className}");
        sb.AppendLine("    {");

        foreach (var field in fields)
        {
            sb.AppendLine($"        public {field.Type} {field.PropertyName}");
            sb.AppendLine("        {");
            sb.AppendLine($"            get => {field.FieldName};");
            sb.AppendLine("            set");
            sb.AppendLine("            {");
            sb.AppendLine($"                this.RaiseAndSetIfChanged(ref {field.FieldName}, value);");
            foreach (var also in field.AlsoNotifyProperties)
            {
                sb.AppendLine($"                this.RaisePropertyChanged(nameof({also}));");
            }
            sb.AppendLine("            }");
            sb.AppendLine("        }");
        }

        sb.AppendLine("    }");

        if (!string.IsNullOrEmpty(firstField.Namespace))
        {
            sb.AppendLine("}");
        }

        return sb.ToString();
    }

    static string GenerateProxyProperties(List<ProxyPropertyInfo> infos)
    {
        var first = infos.First();
        var sb = new StringBuilder();

        // Standard header for generated files
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("using ReactiveUI;");
        sb.AppendLine();

        if (!string.IsNullOrEmpty(first.Namespace))
        {
            sb.AppendLine($"namespace {first.Namespace}");
            sb.AppendLine("{");
        }

        // Use only the leaf class name to avoid nesting errors
        var className = first.ContainingClass.Split('.').Last();
        sb.AppendLine($"    partial class {className}");
        sb.AppendLine("    {");

        foreach (var info in infos)
        {
            sb.AppendLine($"        /// <inheritdoc cref=\"{info.FieldName}.{info.ProxyPropertyPath}\"/>");
            sb.AppendLine($"        public {info.Type} {info.PropertyName}");
            sb.AppendLine("        {");
            sb.AppendLine($"            get => {info.FieldName}.{info.ProxyPropertyPath};");
            sb.AppendLine("            set");
            sb.AppendLine("            {");
            sb.AppendLine($"                if (!global::System.Collections.Generic.EqualityComparer<{info.Type}>.Default.Equals({info.FieldName}.{info.ProxyPropertyPath}, value))");
            sb.AppendLine("                {");
            sb.AppendLine($"                    {info.FieldName}.{info.ProxyPropertyPath} = value;");
            sb.AppendLine($"                    this.RaisePropertyChanged(nameof({info.PropertyName}));");
            foreach (var also in info.AlsoNotifyProperties)
            {
                sb.AppendLine($"                    this.RaisePropertyChanged(nameof({also}));");
            }
            sb.AppendLine("                }");
            sb.AppendLine("            }");
            sb.AppendLine("        }");
        }

        sb.AppendLine("    }");

        if (!string.IsNullOrEmpty(first.Namespace))
        {
            sb.AppendLine("}");
        }

        return sb.ToString();
    }

    static INamedTypeSymbol? GetClassSymbol(GeneratorSyntaxContext context)
    {
        var fieldSyntax = (FieldDeclarationSyntax)context.Node;
        var classDeclaration = fieldSyntax.Ancestors().OfType<ClassDeclarationSyntax>().FirstOrDefault();
        return classDeclaration != null ? context.SemanticModel.GetDeclaredSymbol(classDeclaration) as INamedTypeSymbol : null;
    }

    static bool IsFieldWithRaiseChange(SyntaxNode node) => node is FieldDeclarationSyntax f && f.AttributeLists.SelectMany(al => al.Attributes).Any(a => a.Name.ToString().Contains("RaiseChange"));
    static bool IsFieldWithRaiseChangeProxy(SyntaxNode node) => node is FieldDeclarationSyntax f && f.AttributeLists.SelectMany(al => al.Attributes).Any(a => a.Name.ToString().Contains("RaiseChangeProxy"));

    static FieldInfo? GetFieldInfo(GeneratorSyntaxContext context)
    {
        if (context.Node is not FieldDeclarationSyntax fieldSyntax) return null;
        var variable = fieldSyntax.Declaration.Variables.FirstOrDefault();
        if (variable is null || context.SemanticModel.GetDeclaredSymbol(variable) is not IFieldSymbol fieldSymbol) return null;
        if (!fieldSymbol.GetAttributes().Any(a => a.AttributeClass?.Name == "RaiseChangeAttribute")) return null;

        var classNames = new List<string>();
        var currentType = fieldSymbol.ContainingType;
        while (currentType != null) { classNames.Insert(0, currentType.Name); currentType = currentType.ContainingType; }

        return new FieldInfo(fieldSymbol.Name, ToPascal(fieldSymbol.Name), fieldSymbol.Type.ToDisplayString(), string.Join(".", classNames),
            fieldSymbol.ContainingType.ContainingNamespace.IsGlobalNamespace ? "" : fieldSymbol.ContainingType.ContainingNamespace.ToDisplayString(),
            fieldSymbol.GetAttributes().Where(a => a.AttributeClass?.Name == "AlsoNotifyAttribute").Select(a => a.ConstructorArguments[0].Value?.ToString() ?? "").ToList());
    }

    static List<ProxyPropertyInfo> GetProxyPropertyInfos(GeneratorSyntaxContext context)
    {
        var result = new List<ProxyPropertyInfo>();
        if (context.Node is not FieldDeclarationSyntax fieldSyntax) return result;
        var variable = fieldSyntax.Declaration.Variables.FirstOrDefault();
        if (variable is null || context.SemanticModel.GetDeclaredSymbol(variable) is not IFieldSymbol fieldSymbol) return result;

        var classNames = new List<string>();
        var currentType = fieldSymbol.ContainingType;
        while (currentType != null) { classNames.Insert(0, currentType.Name); currentType = currentType.ContainingType; }

        var ns = fieldSymbol.ContainingType.ContainingNamespace.IsGlobalNamespace ? "" : fieldSymbol.ContainingType.ContainingNamespace.ToDisplayString();

        foreach (var attr in fieldSymbol.GetAttributes().Where(a => a.AttributeClass?.Name == "RaiseChangeProxyAttribute"))
        {
            var path = attr.ConstructorArguments.Length >= 1 ? attr.ConstructorArguments[0].Value?.ToString() ?? "" : "";
            var custom = attr.ConstructorArguments.Length >= 2 ? attr.ConstructorArguments[1].Value?.ToString() : null;
            var finalName = custom ?? ToPascal(path.Split('.').Last());
            result.Add(new ProxyPropertyInfo(finalName, path, DeterminePropertyType(fieldSymbol, path), fieldSymbol.Name, string.Join(".", classNames), ns,
                fieldSymbol.GetAttributes().Where(a => a.AttributeClass?.Name == "AlsoNotifyAttribute").Select(a => a.ConstructorArguments[0].Value?.ToString() ?? "").ToList()));
        }
        return result;
    }

    static string DeterminePropertyType(IFieldSymbol fieldSymbol, string propertyPath)
    {
        var currentType = fieldSymbol.Type;
        foreach (var part in propertyPath.Split('.'))
        {
            var member = FindPropertyOrFieldInTypeHierarchy(currentType, part);
            if (member is IPropertySymbol p) currentType = p.Type;
            else if (member is IFieldSymbol f) currentType = f.Type;
            else return "object";
        }
        return currentType.ToDisplayString();
    }

    static ISymbol? FindPropertyOrFieldInTypeHierarchy(ITypeSymbol type, string memberName)
    {
        var current = type;
        while (current != null)
        {
            var member = current.GetMembers(memberName).FirstOrDefault(m => m is IPropertySymbol or IFieldSymbol);
            if (member != null) return member;
            current = current.BaseType;
        }
        return type.AllInterfaces.SelectMany(i => i.GetMembers(memberName)).FirstOrDefault(m => m is IPropertySymbol or IFieldSymbol);
    }

    static bool ClassHasReactiveUISupport(INamedTypeSymbol symbol)
    {
        var current = symbol;
        while (current != null)
        {
            if (current.BaseType?.ToDisplayString() == "ReactiveUI.ReactiveObject" || current.AllInterfaces.Any(i => i.Name == "IReactiveNotifyPropertyChanged" || i.Name == "IReactiveObject")) return true;
            current = current.BaseType;
        }
        return false;
    }

    static string ToPascal(string name) => name.TrimStart('_') is string t && t.Length > 0 ? char.ToUpper(t[0]) + t.Substring(1) : name;
}